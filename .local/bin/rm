#!/usr/bin/env python3
import pwd
import sys
from getpass import getuser
from os import environ, getppid
from os.path import exists, expanduser
from shutil import which
from subprocess import run
from typing import Iterator

try:
    from my_utils.seq import for_each
except ModuleNotFoundError:
    sys.path.append(expanduser("~/.local/share/python/lib"))
    from my_utils.seq import for_each
from my_utils.os import slice_path


def attach_tag(type_tag, contents):
    return (type_tag, contents)


def parse_args(args: list[str]):
    try:
        double_dash_index = args.index("--")
        return attach_tag(False, args[double_dash_index + 1 :])
    except ValueError:
        return attach_tag(True, args)


def trash(files: list[str], check_dash):
    for_each(
        lambda file: run(["trash", "-f", file], check=True),
        filter(
            lambda file: (not file.startswith("-")) and exists(file)
            if check_dash
            else exists,
            files,
        ),
    )


def get_parent_process_name() -> str:
    parent_pid = getppid()
    with open(f"/proc/{parent_pid}/comm", "r") as f:
        return f.read().rstrip()


def find_rm_exe() -> str:
    def filter_paths(
        path: list[str], slice_obj: slice, exclusion: set[str]
    ) -> Iterator[str]:
        return filter(lambda p: str(slice_path(p, slice_obj)) not in exclusion, path)

    exe = which(
        "rm",
        path=":".join(
            filter_paths(environ["PATH"].split(":"), slice(2), {".", "/root", "/home"})
        ),
    )
    if exe is None:
        raise FileNotFoundError("Could not find 'rm' executable")
    else:
        return exe


def is_in_black_list(parent_process_name: str) -> bool:
    def get_default_shell() -> str:
        return str(slice_path(pwd.getpwnam(getuser()).pw_shell, slice(-1, None)))

    if parent_process_name in {"configure", "make", "makepkg"}:
        return True
    else:
        return (
            parent_process_name.endswith("sh")
            and parent_process_name != get_default_shell()
        )


def main():
    process_name = get_parent_process_name()
    in_black_list = is_in_black_list(process_name)
    if sys.stderr.isatty() and (not in_black_list):
        print(f"[{process_name}] Please use 'trash' when possible", file=sys.stderr)

    check_dash, files = parse_args(sys.argv[1:])
    if (which("trash") is not None) and (not in_black_list):
        trash(files, check_dash)
    else:
        run([find_rm_exe(), *sys.argv[1:]], check=True)


if __name__ == "__main__":
    main()
