#!/usr/bin/env python3
# A stupid script that avoids repeatedly typing the script path
# Depends On: fd, ripgrep, trash-cli, shellcheck, neovim

from sys import argv
from subprocess import run
from os import chdir
from os.path import basename, join, isfile, expanduser
from inspect import getattr_static
from typing import Type
from my_seq import Iterable, for_each, partition


def ensure_length(length: int, mes: str):
    def decorator(old_fn):
        def new_fn(*args, **kwargs):
            lst = args[0] if len(args) > 0 else argv
            if len(lst) < length:
                raise SystemExit(mes)
            else:
                old_fn(*args, **kwargs)

        return new_fn

    return decorator


ensure_one_parameter = ensure_length(1, "Missing one argument")
ensure_two_parameters = ensure_length(2, "Missing two arguments")


def get_full_path(param_list: list[str], dir: str):
    return map(lambda item: join(dir, item), param_list)


def substrings_to_pattern(substrings: Iterable[str]) -> str:
    import re
    from itertools import permutations

    return "|".join(
        map(
            lambda perm: ".*".join(map(re.escape, perm)),
            permutations(substrings),
        )
    )


class Subcommands:
    @staticmethod
    def ls(param_list: list[str], dir: str, opts: str = ""):
        run(
            [
                "ls",
                f"-{opts}F",
                "--color=auto",
                "--group-directories-first",
                *param_list,
            ],
            cwd=dir,
        )

    @staticmethod
    def ll(param_list: list[str], dir: str):
        Subcommands.ls(param_list, dir, opts="lh")

    @staticmethod
    def cat(param_list: list[str], dir: str):
        def display(file: str):
            with open(file, "r") as f:
                print(f.read(), end="")

        def print_separator(i):
            if i != length - 1:
                print("-" * 50, end="\n" * 3)
            else:
                return

        def op(enum: tuple):
            (i, file) = enum
            display(file)
            print_separator(i)

        length = len(param_list)
        chdir(dir)
        for_each(op, enumerate(param_list))

    @staticmethod
    @ensure_one_parameter
    def fd(param_list: list[str], dir: str):
        run(
            [
                "fd",
                "--color",
                "never",
                "--follow",
                substrings_to_pattern(param_list),
                dir,
            ],
            check=True,
        )

    # grep (rg) function
    @staticmethod
    @ensure_one_parameter
    def rg(param_list: list[str], dir: str):
        opts, args = partition(lambda s: s.startswith("-"), param_list)
        args = tuple(args)
        run(
            [
                "rg",
                "--smart-case",
                "--follow",
                *opts,
                substrings_to_pattern(args) if len(args) > 1 else args[0],
                dir,
            ]
        )
        # `rg` returns a non-zero exit code when it does not locate a match,
        # adhering to the traditional Unix shell convention
        # where exit codes are interpreted as boolean values.
        # However, this convention is not ideal as it specially treats and handles integers.
        # A more general and elegant way could be to make the output of a command an object,
        # containing stdout, stderr, and returncode.
        # Programmers can manually specify conditions based on the returncode
        # or any other attribute of the output object.
        # This approach aligns with the principle of type consistency
        # and can make error handling more explicit and robust.

    # trash function
    @staticmethod
    @ensure_one_parameter
    def tr(param_list: list[str], dir: str):
        chdir(dir)
        return for_each(
            lambda file: run(["trash", file], check=True),
            param_list,
        )

    @staticmethod
    @ensure_two_parameters
    def mv(param_list: list[str], dir: str):
        run(["mv", "-i", *param_list], check=True, cwd=dir)

    @staticmethod
    @ensure_two_parameters
    def ln(param_list: list[str], dir: str):
        run(["ln", "-sr", param_list[0], param_list[1]], check=True, cwd=dir)

    @staticmethod
    @ensure_two_parameters
    def cp(param_list: list[str], dir: str):
        run(["cp", "-i", *param_list], check=True, cwd=dir)

    @staticmethod
    @ensure_two_parameters
    def diff(param_list: list[str], dir: str):
        run(["nvim", "-d", *reversed(param_list)], cwd=dir)

    # line count function
    @staticmethod
    @ensure_one_parameter
    def lc(param_list: list[str], dir: str):
        run(["wc", "-l", *param_list], cwd=dir)

    @staticmethod
    @ensure_one_parameter
    def shck(param_list: list[str], dir: str):
        chdir(dir)
        return for_each(
            lambda file: run(["shellcheck", "-x", "-o", "all", file]),
            param_list,
        )


# build a list then expand it to neovim
def edit(param_list: list[str], dir: str):
    import editor
    from os import chmod
    from my_os import get_permission

    def update_permission(permission):
        for_each(
            lambda file: chmod(file, permission),
            filter(
                lambda file: isfile(file) and get_permission(file) != permission,
                param_list,
            ),
        )

    chdir(dir)
    editor.edit(files=param_list)
    update_permission(0o744)


def is_user_defined_member(namespace: Type, member_name: str):
    return (not member_name.startswith("_")) and (member_name in vars(namespace))


@ensure_length(2, f"Missing argument for `{basename(__file__)}`")
def main():
    dir, fn_name = expanduser("~/.local/bin"), argv[1]
    if is_user_defined_member(Subcommands, fn_name):
        getattr_static(Subcommands, fn_name)(argv[2:], dir)
    else:
        edit(argv[1:], dir)


if __name__ == "__main__":
    main()
