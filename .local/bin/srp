#!/usr/bin/env python3
# A stupid script that avoids repeatedly typing the script path
# Depends On: fd, ripgrep, trash-cli, shellcheck, neovim

from sys import argv as sys_argv, exit as sys_exit, modules
from subprocess import run
from os.path import basename, join, isfile, expanduser
from os import chmod, stat
from stat import S_IMODE
from inspect import isfunction, getmodule, currentframe


def ls(param_list, path):
    if param_list == []:
        run(["ls", "-F", "--color=auto", "--group-directories-first", path])
    else:
        for item in param_list:
            file = join(path, item)
            run(["ls", "-F", "--color=auto", "--group-directories-first", file])


def cat(param_list, path):
    def print_necessary_separator():
        if i != len_param_list - 1:
            print("-" * 50, sep="")
            print("\n")
        else:
            return

    len_param_list = len(param_list)
    for i in range(len_param_list):
        item = param_list[i]
        file = join(path, item)
        run(["cat", file])
        print_necessary_separator()


def ensure_one_parameter(param_list):
    if len(param_list) < 1:
        print("Missing argument")
        sys_exit(1)
    else:
        return


def fd(param_list, path):
    ensure_one_parameter(param_list)
    pattern = " ".join(param_list)
    run(["fd", "-t", "f", pattern, path, "-x", "printf", r"%s\n", r"{/}"], check=True)


# grep (rg) function
def rg(param_list, path):
    # if no object is found, 'rg' would return an error, but 'none' is not equal to 'error'
    # see also:
    # https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/
    ensure_one_parameter(param_list)
    pattern = " ".join(param_list)
    run(["rg", "--smart-case", pattern, path])


# rm (trash) function
def rm(param_list, path):
    for item in param_list:
        file = join(path, item)
        run(["trash", file], check=True)


def mv(param_list, path):
    file1 = join(path, param_list[0])
    file2 = join(path, param_list[1])
    run(["mv", "-i", file1, file2], check=True)


def cp(param_list, path):
    file1 = join(path, param_list[0])
    file2 = join(path, param_list[1])
    run(["cp", "-i", file1, file2], check=True)


def d(param_list, path):
    file1 = join(path, param_list[0])
    file2 = join(path, param_list[1])
    run(["nvim", "-d", file1, file2])


diff = d  # function alias


# line count function
def lc(param_list, path):
    for item in param_list:
        file = join(path, item)
        run(["wc", "-l", file])


def shck(param_list, path):
    for item in param_list:
        file = join(path, item)
        run(["shellcheck", "-x", "-o", "all", file])


def pdb(param_list, path):
    for program_name in param_list:
        program_path = join(path, program_name)
        run(["python", "-m", "pdb", program_path])


# build a list then expand it to neovim or emacs
def edit(param_list, path):
    files = []
    for item in param_list:
        file = join(path, item)
        files.append(file)

    import editor

    editor.edit(files=files)

    def check_update_permission():
        for file in files:
            if isfile(file):
                permission = oct(S_IMODE(stat(file).st_mode))
                if permission != 0o744:
                    chmod(file, 0o744)

    check_update_permission()


def is_user_func(name):
    if not name.isidentifier():
        return False
    else:
        built_in_functions = set(dir(__builtins__))

        frame = currentframe()
        if frame is None:
            return False
        else:
            frame_back = frame.f_back
            if frame_back is None:
                return False
            else:
                local_namespace = frame_back.f_locals

        obj = local_namespace.get(name) or globals().get(name)

        if obj is not None:
            module = getmodule(obj)
            if (
                isfunction(obj)
                and name not in built_in_functions
                and module == modules["__main__"]
            ):
                return True
            else:
                return False
        else:
            return False


def main():
    input_list = sys_argv
    path = expanduser("~/.local/bin")

    if len(input_list) < 2:
        print("Missing argument for", basename(__file__))
        sys_exit(1)
    else:
        if (
            is_user_func(input_list[1])
            and input_list[1] != "edit"
            and input_list[1] != "is_user_func"
        ):
            fun = getattr(modules[__name__], input_list[1])
            fun(input_list[2:], path)
        else:
            edit(input_list[1:], path)


if __name__ == "__main__":
    main()
